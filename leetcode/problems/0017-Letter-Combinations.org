* 17. Letter Combinations of a Phone Number.

** Description

Given a string containing digits from ~2-9~ inclusive, return all possible
letter combinations that the number could represent. Return the answer in *any
order*.

A mapping of digits to letters (just like on the telephone buttons) is given
below.

|--------+------------|
| Number | Letters    |
|--------+------------|
|      1 | -          |
|      2 | a, b, c    |
|      3 | d, e, f    |
|      4 | g, h, i    |
|      5 | j, k, l    |
|      6 | m, n, o    |
|      7 | p, q, r, s |
|      8 | t, u, v    |
|      9 | w, x, y, z |
|--------+------------|

*** Example 1

Input: ~digits = "23"~
Output: ~["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]~

*** Example 2

Input: ~digits = ""~
Output: ~[]~

*** Example 3

Input: ~digits = "22"~
Output: ~["aa", "ab", "ac", "ba", "bb", "bc", "ca", "cb", "cc"]~

** Solution

*** Dynamic Programming

The trick to solving this problem is to increment each string number by
number. For example, for the number ~2~ the letters associated are ~a, b, c~.
If this were to be the only number present, then the only possible strings are
the previous. However, if we have a string like ~22~, then how do we proceed?
As mentioned previously, the trick is to first get the strings generated by the
number ~2~, and then we can expand these strings to include the new letters
found on the next ~2~. This can be represented with the following table:

|----------------------------+------+------+------|
| Prev. String / New letters | ~a~  | ~b~  | ~c~  |
|----------------------------+------+------+------|
| ~a~                        | ~aa~ | ~ab~ | ~ac~ |
| ~b~                        | ~ba~ | ~bb~ | ~bc~ |
| ~c~                        | ~ca~ | ~cb~ | ~cc~ |
|----------------------------+------+------+------|

Let's say now that our previous string was not ~22~ but ~223~, then, following
our process our incremental table would be:

|----------------------------+-------+-------+-------|
| Prev. String / New letters | ~d~   | ~e~   | ~f~   |
|----------------------------+-------+-------+-------|
| ~aa~                       | ~aad~ | ~aae~ | ~aaf~ |
| ~ab~                       | ~abd~ | ~abe~ | ~abf~ |
| ~ac~                       | ~acd~ | ~ace~ | ~acf~ |
| ~ba~                       | ~bad~ | ~bae~ | ~baf~ |
| ~bb~                       | ~bbd~ | ~bbe~ | ~bbf~ |
| ~bc~                       | ~bcd~ | ~bce~ | ~bcf~ |
| ~ca~                       | ~cad~ | ~cae~ | ~caf~ |
| ~cb~                       | ~cbd~ | ~cbe~ | ~cbf~ |
| ~cc~                       | ~ccd~ | ~cce~ | ~ccf~ |
|----------------------------+-------+-------+-------|

This general method will always yield the set of strings that can be obtained by
combining the letters given by original input. Now we have to implement our
previous method.

We can use a hash map to keep track of the letters associated with a digit.

#+begin_src python
  digit_to_letters = {
      "2" : ["a", "b", "c"],
      "3" : ["d", "e", "f"],
      "4" : ["g", "h", "i"],
      "5" : ["j", "k", "l"],
      "6" : ["m", "n", "o"],
      "7" : ["p", "q", "r", "s"],
      "8" : ["t", "u", "v"],
      "9" : ["w", "x", "y", "z"],
  }
#+end_src

Now we can begin traversing the string to build the possible combinations. For
this we will keep a queue which will helps us to keep track of the previous
strings formed by the combinations of the previous numbers.

#+begin_src python
  possible_combinations = list()
  for digit in digits:
      # If its the first digit, append its letters to the queue.
      if len(possible_combinations) == 0:
          for letter in number_to_letters[digit]:
              possible_combinations.append(letter)

      # Otherwise, form every possible combinations of the previous strings with
      # the new letter.
      else:
          # New list to keep track of the new combinations.
          new_combinations = list()

          # Traverse the previous combinations and form new ones.
          for combination in possible_combinations:
              for letter in number_to_letters[digit]:
                  new_combinations.append(combination + letter)

          # The new combinations are now the possible ones so far.
          possible_combinations = new_combinations

  return possible_combinations
#+end_src

**** Complexity

Unfortunately for this one, the complexity is not so great. For each digit we
traverse, we have to traverse all of the possible combinations we can build with
the previous digits. For example let's say we have the string ~223~, for the
first digit ~2~ we have no previous strings and the new combinations are ~a, b,
c~. Now, for the next ~2~ we have to traverse the previous combinations to form
~aa, ab, ac, ba, bb, bc, ca, cb, cc~. And finally, for the digit ~3~, we have to
traverse the previous combinations to form the new combinations. This process
takes overall ~3 + 3^2 + 3^3~ traversals. And in some cases, such as for ~7~ and
~9~, we have to build new combinations for four letters. Overall, the time
complexity of this algorithm is ~O(4^n)~.

**** Code

#+begin_src python
  digit_to_letters = {
      "2" : ["a", "b", "c"],
      "3" : ["d", "e", "f"],
      "4" : ["g", "h", "i"],
      "5" : ["j", "k", "l"],
      "6" : ["m", "n", "o"],
      "7" : ["p", "q", "r", "s"],
      "8" : ["t", "u", "v"],
      "9" : ["w", "x", "y", "z"],
  }

  possible_combinations = list()
  for digit in digits:
      # If its the first digit, append its letters to the queue.
      if len(possible_combinations) == 0:
          for letter in number_to_letters[digit]:
              possible_combinations.append(letter)

      # Otherwise, form every possible combinations of the previous strings with
      # the new letter.
      else:
          # New list to keep track of the new combinations.
          new_combinations = list()

          # Traverse the previous combinations and form new ones.
          for combination in possible_combinations:
              for letter in number_to_letters[digit]:
                  new_combinations.append(combination + letter)

          # The new combinations are now the possible ones so far.
          possible_combinations = new_combinations

  return possible_combinations
#+end_src
