* SQL Crash Course - Query Basics

** Query Clauses

Several components or /clauses/ make up the ~select~ statement. While only one
of them is mandatory in MySQL, you can use up to six clauses. The following are
the available clauses and their purpose.

|-------------+----------------------------------------------------------------|
| Clause name | Purpose                                                        |
|-------------+----------------------------------------------------------------|
| ~select~    | Determines which columns to include in the query result set.   |
|-------------+----------------------------------------------------------------|
| ~from~      | Identifies the tables from which to retrieve data, and how     |
|             | the tables should be joined.                                   |
|-------------+----------------------------------------------------------------|
| ~where~     | Filters out unwanted data.                                     |
|-------------+----------------------------------------------------------------|
| ~group by~  | Used to group rows together by common column values.           |
|-------------+----------------------------------------------------------------|
| ~having~    | Filters out unwanted groups.                                   |
|-------------+----------------------------------------------------------------|
| ~order by~  | Sorts the rows of the final result set by one or more columns. |
|-------------+----------------------------------------------------------------|

*** The ~select~ Clause

Even though the ~select~ clause is the first clause of a ~select~ statement, it
is one of the last clauses that the database server evaluates. The reason for
this is that before you can determine what to include in the final result set,
you need to know all of the possible columns that /could/ be included in the
final result set. Here's an initial query:

#+begin_src sql
  SELECT * FROM language;
#+end_src

Which returns the following result set:

|-------------+----------+---------------------|
| language_id | name     | last_update         |
|-------------+----------+---------------------|
|           1 | English  | 2006-02-15 05:02:19 |
|           2 | Italian  | 2006-02-15 05:02:19 |
|           3 | Japanese | 2006-02-15 05:02:19 |
|           4 | Mandarin | 2006-02-15 05:02:19 |
|           5 | French   | 2006-02-15 05:02:19 |
|           6 | German   | 2006-02-15 05:02:19 |
|-------------+----------+---------------------|

In this query, the ~from~ clause lists a single table (~language~), and the
~select~ clause indicates that /all/ columns (designated by ~*~) in the
~language~ table should be included in the result set. In addition, you can
explicitly name the columns you are interested in, such as:

#+begin_src sql
  SELECT language_id, name FROM language;
#+end_src

And we would get the following result:

|-------------+----------|
| language_id | name     |
|-------------+----------|
|           1 | English  |
|           2 | Italian  |
|           3 | Japanese |
|           4 | Mandarin |
|           5 | French   |
|           6 | German   |
|-------------+----------|

**** Column Aliases

You will almost certainly want to assign your own labels to those columns in
your result set that are generated by expressions or built in function calls. We
can do the previous by using /column aliases/ after each element of our ~select~
clause. In order to make our column aliases stand out even more, you also have
the option of using the ~as~ keyword before the alias name, as in:

#+begin_src sql
  SELECT language_id,
         'COMMON' AS language_usage,
         upper(name) AS language_name
  FROM language;       
#+end_src

And get the following result set:

|-------------+----------------+---------------|
| language_id | language_usage | language_name |
|-------------+----------------+---------------|
|           1 | COMMON         | ENGLISH       |
|           2 | COMMON         | ITALIAN       |
|           3 | COMMON         | JAPANESE      |
|           4 | COMMON         | MANDARIN      |
|           5 | COMMON         | FRENCH        |
|           6 | COMMON         | GERMAN        |
|-------------+----------------+---------------|

**** Removing duplicates

In some cases, a query might return duplicate rows of data. For example, if you
were to retrieve the IDs of all actors who appeared in a film, you would see
something like:

#+begin_src sql
  SELECT actor_id FROM film_actor ORDER BY actor_id;
#+end_src

With the result set being:

|----------|
| actor_id |
|----------|
|        1 |
|        1 |
|        1 |
|      ... |
|      200 |
|      200 |
|      200 |
|      200 |
|----------|

If what we're looking for is for unique values, then we can use the ~distinct~
keyword directly after the ~select~ keyword. For example:

#+begin_src sql
  SELECT DISTINCT actor_id FROM film_actor ORDER BY actor_id;
#+end_src

Getting the following result set:

|----------|
| actor_id |
|----------|
|        1 |
|        2 |
|        3 |
|      ... |
|      197 |
|      198 |
|      199 |
|      200 |
|----------|

*** The ~from~ Clause

The ~from~ clause defines the tables used by a query, along with the means of
linking the tables together.

**** Table Links

When requiring information related to more than one table, then we're talking
about /table linking/ which refers on how entities may share some information
that when /joined/ result in some relation. Thus, when more than one table
appears in the ~from~ clause, the conditions used to /link/ the tables must be
included as well. For example, given the following query:

#+begin_src sql
  SELECT customer.first_name,
         customer.last_name,
         time(rental.rental_date) AS rental_time
  FROM customer
       INNER JOIN rental ON customer.customer_id = rental.customer_id
  WHERE date(rental.rental_date) = '2005-06-14';
#+end_src

Return the following result set:

|------------+-----------+-------------|
| first_name | last_name | rental_time |
|------------+-----------+-------------|
| JEFFERY    | PINSON    |    22:53:33 |
| ELMER      | NOE       |    22:55:13 |
| MINNIE     | ROMERO    |    23:00:34 |
| MIRIAM     | MCKINNEY  |    23:07:08 |
| DANIEL     | CABRAL    |    23:09:38 |
| TERRANCE   | ROUSH     |    23:12:46 |
| JOYCE      | EDWARDS   |    23:16:26 |
| GWENDOLYN  | MAY       |    23:16:27 |
| CATHERINE  | CAMPBELL  |    23:17:03 |
| MATTHEW    | MAHAN     |    23:25:58 |
| HERMAN     | DEVORE    |    23:35:09 |
| AMBER      | DIXON     |    23:42:56 |
| TERRENCE   | GUNDERSON |    23:47:35 |
| SONIA      | GREGORY   |    23:50:11 |
| CHARLES    | KOWALSKI  |    23:54:34 |
| JEANETTE   | GREENE    |    23:54:46 |
|------------+-----------+-------------|

The query displays both the ~customer~ table in the columns ~first_name~ and
~second_name~, and the ~rental~ table with the column ~rental_date~, so both
tables are included in the ~from~ clause. The mechanism of linking the two
tables, referred as a /join/, is the customer ID stored in both ~customer~ and
~rental~ tables. Thus, the database server is instructed to use the value of the
~customer_id~ in the ~customer~ table to find all the customer's rentals in the
~rental~ table.

**** Table Aliases

When multiple tables are joined in a single query, we need a way to identify
which table you are referring to when you reference columns in the ~select~,
~where~, ~group by~, ~having~, and ~order by~ clauses. We can use the entire
table name, such as ~employee.employee_id~, or we can assign each table an
/alias/ and use the alias throughout the query. Like before, we can use the keyword
~as~ to table aliases. We give the following example:

#+begin_src sql
  SELECT c.first_name,
         c.last_name,
         time(r.rental_date) AS rental_time,
  FROM customer AS c
       INNER JOIN rental AS r
       ON c.customer_id = r.customer_id
  WHERE date(r.rental_date = '2005-06-14');
#+end_src

*** The ~where~ Clause

Most of the time when performing queries you may want to extract only certain
information from a table, we want a way to /filter/ out those rows that are not
of interest. The ~where~ clause is designed to solve the previous problem. For
example, let's say we want to watch a movie rated G that can be kept for at
least a week, the following query meets the previous criteria:

#+begin_src sql
  SELECT title
  FROM film
  WHERE rating = 'G' and rental_duration >= 7;
#+end_src

Which results in the following set:

|-------------------------|
| title                   |
|-------------------------|
| BLANKET BEVERLY         |
| BORROWERS BEDAZZLED     |
| BRIDE INTRIGUE          |
| CATCH AMISTAD           |
| CITIZEN SHREK           |
| COLDBLOODED DARLING     |
|-------------------------|

*** The ~group by~ and ~having~ Clauses

Sometimes, when viewing information, you may be in a situation where you want to
know some general information about an entity. For example, we may want to know
how many movies a customer has rented but not really know which movies have been
rented, so instead of looking through a table of more than 10,000 rows, we can
write a query that groups the customers and show the information we're looking
for. The ~group by~ clause serves the previous purpose. If then we need to
filter this results, we can use the ~having~ clause.

For example, if we want to know which customers have at least 5 rented movies,
then we can use the following query:

#+begin_src sql
  SELECT c.first_name, c.last_name, count(*)
  FROM customer AS c
      INNER JOIN rental AS r
      ON c.customer_id = r.customer_id
  GROUP BY c.first_name, c.last_name
      HAVING count(*) >= 40;
#+end_src

Which returns the following result set:

|------------+-----------+----------|
| first_name | last_name | count(*) |
|------------+-----------+----------|
| Tammy      | Sanders   |        7 |
| Clara      | Shaw      |        6 |
| Eleanor    | Hunt      |        6 |
| Sue        | Peters    |        5 |
| Marcia     | Dean      |        7 |
|------------+-----------+----------|

*** The ~order by~ Clause

In general, the rows in a result set are not in any particular order. If we want
it to be ordered, we can use the ~order by~ clause to order the result set using
an specified column or expression. For example, if we want to list our customers
and order them by their last them, then we use the following query:

#+begin_src sql
  SELECT first_name, last_name
  FROM customers
  ORDER BY last_name;
#+end_src

We can even order using multiple columns. For example, if we have large set of
customers, then some of them may share a last name, in this case we also want to
order them taking into consideration their first name.

#+begin_src sql
  SELECT first_name, last_name,
  FROM customers
  ORDER BY last_name, first_name;
#+end_src

**** Ascending Order v.s. Descending Order

We can specify if our result set has an /ascending/ or /descending/ order via
the ~asc~ and ~desc~ keywords. The default is ascending, we can add the ~desc~
keyword if we want our set to be on descending order.

#+begin_src sql
  SELECT first_name, last_name
  FROM customers
  ORDER BY last_name DESC;
#+end_src
