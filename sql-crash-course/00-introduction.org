* SQL Crash Course - Introduction

** The Relational Model

*** A Brief Example

In 1970, Dr. E. F. Codd of IBM's research published a papel titled "A Relational
Model of Data for Large Shared Data Banks" that proposed that data be
represented as sets of /tables/. The following example represent how to
represent some client's bank accounts.

|-------------+------------+-----------|
| Customer ID | First Name | Last Name |
|-------------+------------+-----------|
|           1 | George     | Blake     |
|           2 | Sue        | Smith     |
|-------------+------------+-----------|

|------------+----------------|
| Product ID | Name           |
|------------+----------------|
| CHK        | Checking       |
| SAV        | Savings        |
| MM         | Money market   |
| LOC        | Line of Credit |
|------------+----------------|

|------------+------------+-------------+---------|
| Account ID | Product ID | Customer ID | Balance |
|------------+------------+-------------+---------|
|        103 | CHK        |           1 | $75.00  |
|        104 | SAV        |           1 | $250.00 |
|        105 | CHK        |           2 | $783.00 |
|        106 | MM         |           2 | $500.00 |
|        107 | LOC        |           2 | $0.00   |
|------------+------------+-------------+---------|

|----------------+------------------+------------+----------+------------|
| Transaction ID | Transaction Type | Account ID | Amount   |       Date |
|----------------+------------------+------------+----------+------------|
|            978 | DBT              |        103 | $100.00  | 2004-01-22 |
|            979 | CDT              |        103 | $25.00   | 2004-02-05 |
|            980 | DBT              |        104 | $250.00  | 2004-03-09 |
|            981 | DBT              |        105 | $1000.00 | 2004-03-25 |
|----------------+------------------+------------+----------+------------|

Each table in a relational database includes information that uniquely
identifies a row in that table (known as the *primary key*), along with
additional information needed to describe the entity completely. In the previous
example, at the Customer Table, the /Customer ID/ column holds a different
number for each customer. No other customer will ever be assigned the same
identifier as other customer.

*** Terminology

An *entity* is something of interest to the database. In the previous example,
this included customers, products, transactions, etc. A *column* is an
individual piece of data stored in a table which is related to an entity. A
*row* is a set of columns that together completely describe an entity or some
action on an entity; it is also known as a *record*. A *table* is a set of rows,
held either in memory (nonpersistent) or on a permanent state (persistent). The
*result set* is another name for a /nonpersistent table/, generally the result
of an SQL query. The *primary key* is the unique identifier for each row in the
table, it can consist of one or more columns. Finally a *foreign key* is an
identifier to locate a row on another table, it can consist of one or more
columns.

** What is SQL?

SQL is basically a language for manipulating the data found in relational
tables.

*** SQL Statements

The SQL language is divided into several distinct parts: the *SQL schema
statements*, which are used to define the data structures stored in the
database; *SQL statements*, which are used to manipulate the data structures
previously defined; and *SQL transaction statements*, which are used to begin,
end and roll back transactions. For example, to create a new table in your
database, you would use the SQL schema statement ~create table~, whereas the
process of populating your new table with data would require the SQL data
statement ~insert~.

Here's an example of an SQL schema statement to create a table called
~corporation~.

#+begin_src sql
      CREATE TABLE corporation
             (corp_id SMALLINT,
             name VARCHAR(30),
             CONSTRAINT pk_corporation PRIMARY KEY (corp_id));
#+end_src

The previous statement creates a table with two columns, ~corp_id~ and ~name~,
with the first column being the primary key for the rows of the table. Now
here's an SQL statement to insert a row into the ~corporation~ table.

#+begin_src sql
  INSERT INTO corporation (corp_id, name)
  VALUES (27, 'Acme Paper Corporation');
#+end_src

This statement adds a row to the corporation table with a value of ~27~ for the
~corp_id~ column and a value of ~Acme Paper Corporation~ for the name column.

Finally, here's a simple ~select~ statement to retrieve the data that was just
created.

#+begin_src sql
  SELECT name FROM corporation WHERE corp_id = 27;
#+end_src

Executing the previous statement returns the following table:

|------------------------|
| name                   |
|------------------------|
| Acme Paper Corporation |
|------------------------|


*** SQL Data Types

In general, all popular database servers have the capacity to store the same
types of data, such as strings, dates, and numbers. Where they typically differ
is in the specialty data types, such as XML and JSON documents or spatial data.
For these notes we will be exploring ~MySQL~ data types, in this case the
character, date, and numeric data types.

**** Character Data

The character data can be stored as either fixed-length or variable-length
strings; the difference is that fixed length strings are right-padded with
spaces and always consume the same number of bytes, and variable length strings
are not right-padded with spaces and don't always consume the number of bytes.

When defining a character column, you must specify the maximum size of any
string to be stored in the column. For example, if you want to store strings up
to 20 characters in length, you could use either of the following definitions:

#+begin_src sql
  char(20)    /* fixed-length */
  varchar(20) /* variable-length */
#+end_src

The maximum length for a ~char~ column is currently 255 bytes, whereas ~varchar~
columns can be up to 65,535 bytes.

**** Text data

If you need to store longer strings that might exceed the 64KB limit for
~varchar~ columns (such as emails, XML documents, etc.), then you will want to
use one of the text types.

|--------------+-------------------------|
| Text type    | Maximum number of bytes |
|--------------+-------------------------|
| ~tinytext~   | 255                     |
| ~text~       | 65,535                  |
| ~mediumtext~ | 16,777,215              |
| ~longtext~   | 4,294,967,295           |
|--------------+-------------------------|

There are some considerations to be taken when using the previous data types:

- If the data exceeds the maximum size of the type, the data will be truncated.
  
- Trailing spaces will not be removed when data is loaded into the column.
  
- When sorting this data types, only the first 1024 bytes are considered, this
  limit can be changed.

- MySQL has different text types. SQL Server has a single ~text~ type for large
  character data, whereas DB2 and Oracle use a data type called ~clob~ for
  /Character Large Object/.

**** Numeric Data

The numeric data, contrary to popular opinion, may represent several things. For
example, boolean types, a system-generated primary key for a transaction table,
the amount of items in a shopping basket, or positional data, they may all be
numeric data but they represent different things.

To handle these data types, MySQL has several different numeric data types. the
most commonly used numeric types are those used to store whole numbers, or
/integers/. When specifying one of these types, you may also specify that the
data is /unsigned/, which tells the server that all data stored in the column
will be greater than or equal to zero.

|-------------+---------------------------------+--------------------|
| Type        | Signed Range                    | Unsigned Range     |
|-------------+---------------------------------+--------------------|
| ~tinyint~   | -128 to 127                     | 0 to 255           |
| ~smallint~  | -32,768 to 32,767               | 0 to 65,535        |
| ~mediumint~ | −8,388,608 to 8,388,607         | 0 to 16,777,215    |
| ~int~       | −2,147,483,648 to 2,147,483,647 | 0 to 4,294,967,295 |
| ~bigint~    | −2^63 to 2^63 - 1               | 0 to 2^64 - 1      |
|-------------+---------------------------------+--------------------|

Given an integer type, MySQL allocates an appropriate amount of space to store
the data. There are also data types for floating numbers like ~float(p, s)~ and
~double(p, s)~ where ~p~ is the number of digits the number before the decimal
point has, and ~s~ is the number of digits the number of digits the number after
the decimal point has. For example, ~float(4, 2)~ will be able to store numbers
like 27.44 and 8.19, but the number 17.8675 would be rounded to 17.87, and the
number 178.375 will return an error.
